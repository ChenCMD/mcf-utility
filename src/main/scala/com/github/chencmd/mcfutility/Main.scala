package com.github.chencmd.mcfutility

import com.github.chencmd.mcfutility.utils.Datapack
import com.github.chencmd.mcfutility.utils.FS
import com.github.chencmd.mcfutility.utils.Path

import cats.data.EitherT
import cats.data.StateT
import cats.effect.Async
import cats.effect.ExitCode
import cats.effect.IOApp
import cats.effect.implicits.*
import cats.implicits.*
import cats.kernel.Semigroup
import cats.mtl.Raise

import scala.io.Codec
import scala.io.Source

import java.nio.charset.CodingErrorAction
import mouse.all.*

object Main extends IOApp {
  // Map[A, Map[B, List[C]]] = FileType B の File C は File A を参照している

  type References = Map[String, Map[Datapack.FileType, Set[String]]]
  extension [K1, K2, A: Semigroup](m: Map[K1, Map[K2, A]]) {
    def updatedWith(k1: K1)(k2: K2)(f: Option[A] => Option[A]): Map[K1, Map[K2, A]] = {
      m.updatedWith(k1)(m2 => m2.orEmpty.updatedWith(k2)(f).some)
    }
  }

  override def run(args: List[String]) = {
    given codec: Codec = Codec("UTF-8")
    codec.onMalformedInput(CodingErrorAction.REPLACE)
    codec.onUnmappableCharacter(CodingErrorAction.REPLACE)

    def run[F[_]]()(using F: Async[F], R: Raise[F, String]): F[ExitCode] = for {
      pwd   <- F.delay(System.getProperty("user.dir"))
      files <- FS.readDir(pwd, recursive = true)
      refs  <- files.traverse { file =>
        for {
          lines      <- StateT.liftF(F.delay(Source.fromFile(file).getLines().toList))
          fileType   <- StateT.pure(Datapack.getFileTypeOpt(file, pwd))
          references <- StateT.pure {
            fileType match {
              case Some(Datapack.FileType.Advancement) => {
                val funcOpt = for {
                  rewards <- ujson.read(lines.mkString).obj.get("rewards")
                  func    <- rewards.obj.get("function")
                } yield func.str
                funcOpt.toList
              }
              case Some(Datapack.FileType.TagFunction) => Datapack.parseTags(lines.mkString)
              case Some(Datapack.FileType.Function)    => {
                val regex =
                  "^(?:execute .* run )?(?:schedule (?:function|clear)|function) (\\S+).*".r
                lines
                  .map(_.trim)
                  .filterNot(_.startsWith("#"))
                  .filter(regex.matches)
                  .map(regex.replaceAllIn(_, "$1"))
              }
              case _                                   => List.empty
            }
          }
          _          <- {
            references.traverse_ { referenceTo =>
              StateT.modify {
                (_: References).updatedWith(referenceTo) { refs =>
                  Some(refs.orEmpty.updatedWith(fileType.get) { refsWithFileType =>
                    Some(refsWithFileType.orEmpty + Datapack.getResourcePath(file, pwd))
                  })
                }
              }
            }
          }
        } yield ()
      }.runEmptyS
      _     <- FS.writeFile(
        Path.join(pwd, "refs.txt"),
        for {
          (a1, a2) <- refs.toList
          (b1, b2) <- a2.toList
          c        <- b2.toList
        } yield s""""$a1" --> $b1${"[^a-zA-Z0-9]".r.replaceAllIn(s"$b1$c", "")}[["$b1 / $c"]]"""
      )
      _ <- {
        files
          .filter(p => p.endsWith(".mcfunction"))
          .parTraverse_ { file =>
            for {
              lines  <- F.delay(Source.fromFile(file).getLines().toList)
              rp     <- F.pure(Datapack.getResourcePath(file, pwd))
              impDoc <- F.pure {
                Datapack.generateIMPDoc(
                  rp,
                  refs
                    .get(rp)
                    .map(_.mapKeys(_.some))
                    .map(Datapack.IMPDocAccessor.Within.apply)
                    .getOrElse(Datapack.IMPDocAccessor.Private),
                  List("Generated by MCF-Utility")
                )
              }
              _      <- FS.writeFile(file, impDoc :: lines.dropWhile(_.isEmpty))
            } yield ()
          }
      }
    } yield ExitCode.Success

    def handle[F[_], String](
      program: EitherT[F, String, ExitCode]
    )(using F: Async[F]): F[ExitCode] = {
      program.value.flatMap {
        case Right(e)  => e.pure[F]
        case Left(err) => F.delay(println(err)) as ExitCode.Error
      }

    }
    handle(run())
  }
}
